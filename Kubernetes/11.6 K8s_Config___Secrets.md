# **11.6 : Production Best Practices ‚Äì Secure, Scalable Config Management**

https://drive.google.com/file/d/10W-FxaK9hp92ogW4l5q9LusTY0Hc_LwX/view?usp=sharing

### üéØ What It Is

A set of **real-world, battle-tested practices** for using **ConfigMaps & Secrets** safely and efficiently in **production Kubernetes clusters**.

> ‚úÖ Goal: Avoid common pitfalls, ensure security, and enable smooth operations.
> 

### üí° Real-World Analogy

> Like following building codes for a skyscraper ‚Äî not glamorous, but keeps everything safe, maintainable, and compliant.
> 

---

### üß™ Example: Secure Production Workflow with External Secrets

**Step 1: Store secrets in a secure vault (e.g., HashiCorp Vault)**

‚Üí Never in Git.

**Step 2: Use External Secrets Operator (ESO) to sync to Kubernetes**

```yaml
# external-secret.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
meta
  name: prod-db-secret
  namespace: app-prod
spec:
  secretStoreRef:
    name: vault-backend
    kind: ClusterSecretStore
  target:
    name: db-creds  # ‚Üê Creates a Kubernetes Secret
  data:
  - secretKey: password
    remoteRef:
      key: prod/db
      property: password

```

**Step 3: Use the synced Secret in your app**

```yaml
env:
- name: DB_PASSWORD
  valueFrom:
    secretKeyRef:
      name: db-creds
      key: password

```

‚úÖ **Result**:

- Secrets never touch Git or CI/CD logs
- Kubernetes Secrets are **auto-synced and rotated**
- RBAC controls who can access what

---

### ‚úÖ Summary: 6 Golden Rules for Production

| Rule | ConfigMap | Secret |
| --- | --- | --- |
| **1. Never commit to Git** | ‚ùå (safe) | ‚úÖ **Never!** |
| **2. Use least-privilege RBAC** | Restrict `get configmaps` | Restrict `get secrets` |
| **3. Prefer volume mounts for files** | ‚úÖ For config files | ‚úÖ For certs/keys |
| **4. Use `stringData` for Secrets** | N/A | ‚úÖ Always |
| **5. Enable etcd encryption** | Optional | ‚úÖ **Required** |
| **6. Use external secret managers** | Not needed | ‚úÖ Vault, AWS, GCP |

---

### ‚ùì Common Questions

**Q: What is External Secrets Operator (ESO)?**

‚û°Ô∏è A Kubernetes controller that **syncs secrets from external systems** (Vault, AWS Secrets Manager, Azure Key Vault) into Kubernetes Secrets.

**Q: Can I use Helm with Secrets?**

‚úÖ Yes ‚Äî but **never store secrets in `values.yaml`**. Use:

```bash
helm install myapp . --set db.password=$DB_PASS

```

**Q: How do I rotate secrets safely?**

1. Update secret in Vault
2. ESO auto-updates Kubernetes Secret
3. **Rolling restart** of Pods (via annotation hash or `kubectl rollout restart`)

**Q: Is base64 encoding enough for Secrets?**

‚ùå **No!** Always enable **etcd encryption at rest**:

```yaml
# /var/lib/rancher/k3s/server/etcd-encryption-config.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources: ["secrets"]
  providers:
  - aesgcm:
      keys:
      - name: key1
        secret: <32-byte-base64-key>

```

Then start k3s with:

- `-secrets-encryption-config=/path/to/etcd-encryption-config.yaml`

---

### üõ†Ô∏è Best Practices Checklist

‚úÖ **For ConfigMaps**:

- Store in Git (it‚Äôs safe)
- Use `immutable: true` for stable config
- Mount as volume for auto-updating files

‚úÖ **For Secrets**:

- **Never store in Git**
- Use **`stringData`** for readability
- **Enable etcd encryption at rest**
- Use **External Secrets Operator (ESO)** in production
- Restrict access with **RBAC**
- Rotate secrets regularly

‚úÖ **For Both**:

- Use **namespace-scoped** resources
- Add **resource labels** (`app: myapp`, `env: prod`)
- Validate with **`kubectl auth can-i`** before deploying