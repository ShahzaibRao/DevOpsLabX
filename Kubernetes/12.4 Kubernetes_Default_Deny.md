# 12.4 : Default Deny Policies (Namespace Isolation)**

### ğŸ¯ What It Is

A **â€œdefault denyâ€ NetworkPolicy** blocks **all traffic** (ingress and/or egress) in a namespace by default â€” then you **explicitly allow only whatâ€™s needed**.

> âœ… This is the gold standard for security in multi-tenant or production clusters.
> 

### ğŸ’¡ Real-World Analogy

> Like a secure data center:
> 
> - All doors are **locked by default**
> - Access is granted **only after approval** (whitelisted traffic)

---

### ğŸ§ª Example: Isolate the `prod` Namespace

**Step 1: Create a â€œdefault deny allâ€ policy for `prod`**

```yaml
# default-deny-prod.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
meta
  name: default-deny-all
  namespace: prod
spec:
  podSelector: {}           # â† Applies to ALL Pods in namespace
  policyTypes:
  - Ingress
  - Egress
  ingress: []               # â† Deny all incoming
  egress: []                # â† Deny all outgoing

```

Apply it:

```bash
kubectl create namespace prod
kubectl apply -f default-deny-prod.yaml

```

âœ… **Result**:

- No Pod in `prod` can talk to **anything inside or outside the cluster**
- Even `kubectl exec` + `curl localhost` works, but **no network calls**

---

### ğŸ§ª Step 2: Allow Essential Traffic (e.g., DNS + Internal Services)

Now, **add allow rules** for whatâ€™s needed:

```yaml
# allow-dns-and-backend.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
meta
  name: allow-dns-and-backend
  namespace: prod
spec:
  podSelector:
    matchLabels:
      app: frontend
  policyTypes:
  - Egress
  egress:
  # Allow DNS (required for service name resolution)
  - ports:
    - port: 53
      protocol: UDP
    - port: 53
      protocol: TCP

  # Allow frontend â†’ backend
  - to:
    - podSelector:
        matchLabels:
          app: backend
    ports:
    - port: 80

```

Apply:

```bash
kubectl apply -f allow-dns-and-backend.yaml

```

Now:
âœ… `frontend` can resolve `backend` and connect to it

âŒ `frontend` **cannot** reach the internet or other namespaces

---

### âœ… Summary YAML

```yaml
# Default deny ALL
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
meta
  name: default-deny
  namespace: my-ns
spec:
  podSelector: {}
  policyTypes: ["Ingress", "Egress"]
  ingress: []
  egress: []

```

> ğŸ”‘ Key Trick:
> 
> - `podSelector: {}` = **all Pods** in the namespace
> - Empty `ingress/egress` = **deny all**

---

### â“ Common Questions

**Q: Do I need separate policies for ingress and egress?**

âœ… You can combine them (as above), or split into two policies â€” same effect.

**Q: Does this block traffic within the same Pod (localhost)?**

âŒ No! `localhost` traffic is **not affected** â€” NetworkPolicy only applies to **Pod-to-Pod** or **Pod-to-external**.

**Q: What about kube-system Pods (CoreDNS, etc.)?**

â¡ï¸ They run in **other namespaces** â€” so your `prod` policy doesnâ€™t affect them.

âœ… But your `prod` Pods **canâ€™t reach CoreDNS** unless you allow DNS!

**Q: Can I apply default deny cluster-wide?**

âŒ No â€” NetworkPolicy is **namespace-scoped**.

âœ… Apply it to **every namespace** you want to secure.

---

### ğŸ› ï¸ Best Practices

1. âœ… **Apply default deny to every production namespace**
2. âœ… **Always allow DNS** (port 53 UDP/TCP) if using service names
3. âœ… **Label namespaces** (`env: prod`, `team: finance`) for easier policy management
4. âœ… **Test with a debug Pod**:
    
    ```bash
    kubectl run debug -n prod --image=busybox --rm -it -- sh
    / # nslookup backend  # Should work if DNS allowed
    / # wget -qO- <http://backend>  # Should work if policy allows
    
    ```
    
5. âœ… **Use CI/CD to enforce** default-deny in new namespaces

---