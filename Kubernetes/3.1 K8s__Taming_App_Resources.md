# 3.1 : Resource Requests & Limits

https://drive.google.com/file/d/16snilNvcm5kKAWoRmJy0ub-xajEUTnIY/view?usp=sharing

### ğŸ” YAML Breakdown

```yaml
apiVersion: v1
kind: Pod
meta
  name: nnwebserver
spec:
  containers:
    - name: nnwebserver
      image: nginx
      resources:
        requests:        # â† Minimum guaranteed resources
          cpu: "500m"    # = 0.5 CPU core
          memory: "128Mi" # = 128 Mebibytes
        limits:          # â† Maximum allowed resources
          cpu: "1000m"   # = 1.0 CPU core
          memory: "256Mi" # = 256 Mebibytes
      ports:
        - containerPort: 80
          name: http
          protocol: TCP

```

---

### ğŸ“Œ Core Concepts: `requests` vs `limits`

| Term | Meaning | Used By | What Happens If Exceeded? |
| --- | --- | --- | --- |
| **`requests`** | **Guaranteed minimum** resources the container **needs** to start. | **Kubernetes Scheduler** â†’ decides **which node** can run this Pod. | âœ… Never exceeded by scheduler â€” Pod wonâ€™t be placed on a node without enough free `requests`. |
| **`limits`** | **Hard ceiling** â€” container **cannot use more** than this. | **Kubelet + Container Runtime** (e.g., containerd) | - **CPU**: Throttled (slowed down)<br>- **Memory**: **OOMKilled** (Pod crashes!) |

> ğŸ’¡ Units Explained:
> 
> - `500m` = **500 milliCPU** = **0.5 CPU core**
> - `1000m` = **1 full CPU core**
> - `128Mi` = **128 Mebibytes** (1 MiB = 1024Â² bytes) â†’ **not** 128 MB (1000Â²)

> âœ… Best Practice:
> 
> 
> Always set **both `requests` and `limits`** in production.
> 
> Without them, your Pod is **BestEffort** (lowest priority, first to be evicted!).
> 

---

### ğŸ” How Kubernetes Uses This

1. **Scheduling**:
    
    Scheduler checks: *"Does any node have â‰¥500m CPU and â‰¥128Mi free memory?"*
    
    â†’ Only then places the Pod.
    
2. **Runtime Enforcement**:
    - If app tries to use **>1 CPU** â†’ itâ€™s **throttled** (still runs, but slower).
    - If app tries to use **>256Mi memory** â†’ **Killed immediately** with **OOMKilled** status.
3. **QoS Class**:
    
    Because `requests` â‰  `limits` (CPU: 500m â‰  1000m), this Pod is **Burstable** (medium priority).
    

> ğŸ¯ Goal: Prevent one noisy app from starving others on the same node.
> 

---

### ğŸ§ª Lab: Deploy & Observe Resource Behavior

### ğŸ”§ Part 1: Deploy the Pod

```bash
# Apply the Pod
kubectl apply -f pod-with-resource-limits.yml

# Check status
kubectl get pods

# Describe to see resources + QoS class
kubectl describe pod nnwebserver | grep -A 5 -B 2 "Limits\\|QoS"

```

âœ… **Expected Output**:

```
Limits:
  cpu:     1
  memory:  256Mi
Requests:
  cpu:     500m
  memory:  128Mi
QoS Class: Burstable

```

---

### ğŸ”§ Part 2: Simulate CPU Stress (Optional)

> ğŸ§ª Only if you want to see CPU throttling (requires a stress tool).
> 

```bash
# Install stress-ng in the container (if image allows)
kubectl exec -it nnwebserver -- sh

# Inside container:
apt update && apt install -y stress-ng    # if Debian-based
stress-ng --cpu 2 --timeout 60s           # try to use 2 CPUs

```

> ğŸ” Observe: CPU usage will be capped at 1 core (throttled). Pod wonâ€™t crash.
> 

---

### ğŸ”§ Part 3: Simulate Memory Overuse (âš ï¸ Pod will crash!)

> âš ï¸ This will kill the Pod â€” great for learning OOM behavior.
> 

```bash
# Run a memory-hogging command
kubectl exec nnwebserver -- sh -c "python3 -c 'a = \\"x\\" * (300 * 1024 * 1024)'"

```

> ğŸ’¥ Result:
> 
> - Pod status becomes **`OOMKilled`**
> - Restart count increases (if `restartPolicy: Always`)
> - Check with:
>     
>     ```bash
>     kubectl describe pod nnwebserver | grep -i oom
>     
>     ```
>     

---

### â“ Common Questions

**Q: What if I only set `limits`?**

A: Kubernetes **copies `limits` â†’ `requests`** automatically. So it becomes **Guaranteed** QoS.

**Q: What if I set no resources?**

A: Pod is **BestEffort** â€” lowest priority, **first to be evicted** under memory pressure.

**Q: Can I set fractional CPU like `0.5`?**

A: Yes! But **`500m` is preferred** (more explicit).

**Q: Why use `Mi` instead of `M`?**

A: `Mi` = **Mebibyte** (1024Â²), `M` = **Megabyte** (1000Â²). Kubernetes uses **binary units** (`Ki`, `Mi`, `Gi`).

---

### â¡ï¸ Summary

âœ… **`requests`** = minimum needed â†’ used for **scheduling**.

âœ… **`limits`** = maximum allowed â†’ enforced at **runtime**.

âš ï¸ **Memory overuse â†’ OOMKilled** (crash!).

âš ï¸ **CPU overuse â†’ throttled** (slowed, but survives).

ğŸ“Š This Pod is **Burstable** QoS (because requests < limits).

âœ… Always set resources in production!