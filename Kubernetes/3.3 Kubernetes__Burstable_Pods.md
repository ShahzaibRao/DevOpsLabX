# 3.3 : QoS Class â€“ **Burstable**

https://drive.google.com/file/d/1i6DcsQp3H-3PkiLRQQR5dnn5O_dCDg_b/view?usp=sharing

### ðŸ” YAML Breakdown

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nnappone
  namespace: learning
  labels:
    app: nnappone
spec:
  containers:
    - name: crackone-app
      image: nginx
      resources:
        requests:
          memory: "150Mi"   # â† Minimum guaranteed
        limits:
          memory: "250Mi"   # â† Maximum allowed
# âŒ No CPU resources defined!

```

> ðŸ” Key Observation:
> 
> - Only **memory** has `requests` and `limits`
> - **CPU** has **no resources defined**
> â†’ This is **enough** to make the Pod **Burstable** (not BestEffort, not Guaranteed)

---

### ðŸ“Œ What Makes a Pod "Burstable"?

A Pod is **Burstable** if **at least one** of these is true:

- It has **`requests` â‰  `limits`** for any resource (e.g., memory: 150Mi â‰  250Mi), **OR**
- It has **`requests` or `limits` defined for only some resources** (e.g., memory defined, but CPU missing)

> âœ… Your Pod qualifies because:
> 
> - Memory: `requests (150Mi)` < `limits (250Mi)` â†’ **burst allowed**
> - CPU: **not defined** â†’ treated as **BestEffort for CPU**, but **Burstable overall**

> ðŸŽ¯ Kubernetes Rule:
> 
> 
> **Burstable = Not BestEffort AND Not Guaranteed**
> 

---

### ðŸ†š QoS Comparison (Memory Focus)

| QoS Class | Memory `requests` | Memory `limits` | CPU Defined? | Eviction Priority |
| --- | --- | --- | --- | --- |
| **BestEffort** | âŒ | âŒ | âŒ | ðŸ”´ **First** |
| **Burstable** | âœ… (150Mi) | âœ… (250Mi) | âŒ | ðŸŸ¡ **Medium** |
| **Guaranteed** | âœ… (e.g., 200Mi) | âœ… (=200Mi) | âœ… (equal req/lim) | ðŸŸ¢ **Last** |

> ðŸ’¡ Burstable Behavior:
> 
> - Gets **150Mi guaranteed** at startup (scheduler reserves this).
> - Can **burst up to 250Mi** if node has free memory.
> - If memory pressure occurs:
>     - Evicted **after** BestEffort Pods
>     - Evicted **before** Guaranteed Pods
>     - Among Burstable Pods: those **using more than requested** are killed first.

---

### ðŸ§ª Lab: Deploy Burstable Pod & Verify QoS

### ðŸ”§ Steps

```bash
# 1. Create namespace
kubectl create namespace learning

# 2. Apply the Pod
kubectl apply -f pod-simple-qos-burstable.yml

# 3. Check Pod status
kubectl get pods -n learning

# 4. Describe Pod â†’ check QoS Class and resources
kubectl describe pod nnappone -n learning | grep -A 5 -B 2 "QoS\\|Limits\\|Requests"

# âœ… Expected output:
# Requests:
#   memory: 150Mi
# Limits:
#   memory: 250Mi
# QoS Class: Burstable

# 5. (Optional) Extract QoS via JSONPath
kubectl get pod nnappone -n learning -o jsonpath='{.status.qosClass}{"\\n"}'

# 6. Clean up
kubectl delete pod nnappone -n learning
kubectl delete namespace learning

```

---

### ðŸ’¡ Real-World Use Case for Burstable

Most **web apps**, **APIs**, and **stateless services** use **Burstable** because:

- They have **baseline usage** (e.g., 150Mi idle)
- But need to **handle traffic spikes** (burst to 250Mi)
- Donâ€™t require **strict guarantees** (like databases might)

> âœ… Best practice:
> 
> 
> Always set **at least memory `requests`** â†’ avoids BestEffort, improves scheduling.
> 

---

### â“ Common Questions

**Q: What if I define CPU but not memory?**

A: Still **Burstable**! As long as **any resource** has `requests`/`limits`, itâ€™s not BestEffort.

**Q: Can I have Burstable with only `requests` (no `limits`)?**

A: **Yes!** Example:

```yaml
resources:
  requests:
    memory: "128Mi"
# No limits â†’ still Burstable

```

> âš ï¸ But not recommended â€” without limits, a memory leak could crash the node!
> 

**Q: Why is CPU missing here?**

A: The author focused on **memory QoS**. In practice, define **both**:

```yaml
resources:
  requests:
    cpu: "100m"
    memory: "128Mi"
  limits:
    cpu: "500m"
    memory: "256Mi"

```

---

### âž¡ï¸ Summary

âœ… **Burstable** = flexible resource usage with **baseline guarantee**.

âœ… Triggered by:

> requests < limits, ORPartial resource definition (e.g., memory only)
âš ï¸ Safer than BestEffort, but less protected than Guaranteed.
ðŸ” Verify with: kubectl describe pod | grep "QoS Class"
âœ… Ideal for most stateless apps.
>