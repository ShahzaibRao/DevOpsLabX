# 3.4 : QoS Class â€“ **Guaranteed**

https://drive.google.com/file/d/171ZpDsWSlwVy02I4-5Z6Q7dCfaIKxqRw/view?usp=sharing

### ğŸ” YAML Breakdown

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nnappone
  namespace: learning
  labels:
    app: nnappone
spec:
  containers:
    - name: crackone-app
      image: nginx
      resources:
        requests:
          memory: "250Mi"
          cpu: "400m"
        limits:
          memory: "250Mi"   # â† Same as requests!
          cpu: "400m"       # â† Same as requests!

```

> âœ… Key Observation:
> 
> 
> For **every container** and **every resource** (CPU + memory):
> 
> **`requests == limits`**
> 

> ğŸ¯ This is the ONLY requirement for Guaranteed QoS.
> 

---

### ğŸ“Œ What Is "Guaranteed" QoS?

A Pod gets **Guaranteed** QoS **if and only if**:

- Every container in the Pod defines **both `requests` and `limits`** for **CPU and memory**, **AND**
- For **each resource**, `requests == limits`

> ğŸ’¡ Why "Guaranteed"?
> 
> 
> Kubernetes **reserves exactly 400m CPU + 250Mi memory** on a node **before scheduling**.
> 
> The Pod will **never be starved** of these resources (as long as the node is healthy).
> 

---

### ğŸ†š Full QoS Comparison

| QoS Class | CPU `req == lim`? | Memory `req == lim`? | Eviction Priority | Use Case |
| --- | --- | --- | --- | --- |
| **BestEffort** | âŒ Not defined | âŒ Not defined | ğŸ”´ **First** | Debug pods, labs |
| **Burstable** | âŒ (or missing) | âŒ (or missing) | ğŸŸ¡ **Medium** | Web apps, APIs |
| **Guaranteed** | âœ… **Yes** | âœ… **Yes** | ğŸŸ¢ **Last** | Databases, monitoring, critical services |

> ğŸ›¡ï¸ Guaranteed Pods are NEVER evicted due to resource pressure â€” unless the node itself fails.
> 

---

### ğŸ§ª Lab: Deploy Guaranteed Pod & Verify QoS

### ğŸ”§ Steps

```bash
# 1. Create namespace
kubectl create namespace learning

# 2. Apply the Pod
kubectl apply -f pod-simple-qos-guaranteed.yml

# 3. Check Pod status
kubectl get pods -n learning

# 4. Describe Pod â†’ verify resources and QoS
kubectl describe pod nnappone -n learning | grep -A 5 -B 2 "QoS\\|Limits\\|Requests"

# âœ… Expected output:
# Requests:
#   cpu:     400m
#   memory:  250Mi
# Limits:
#   cpu:     400m
#   memory:  250Mi
# QoS Class: Guaranteed

# 5. (Optional) Confirm via JSONPath
kubectl get pod nnappone -n learning -o jsonpath='{.status.qosClass}{"\\n"}'
# Output: Guaranteed

# 6. Clean up
kubectl delete pod nnappone -n learning
kubectl delete namespace learning

```

---

### ğŸ’¡ When to Use Guaranteed QoS?

âœ… **Critical stateful workloads**:

- Databases (MySQL, PostgreSQL, Redis)
- Monitoring agents (Prometheus, Fluentd)
- Real-time systems (trading, telecom)

âœ… **Predictable performance required**

âœ… **Cannot tolerate throttling or eviction**

> âš ï¸ Trade-off:
> 
> - Uses **more cluster capacity** (no overcommit on these resources)
> - Harder to schedule if cluster is fragmented

---

### â“ Common Questions

**Q: What if one container is Guaranteed, but another isnâ€™t?**

A: The **entire Pod becomes Burstable** (QoS is determined by the **lowest** class among containers).

**Q: Can I omit CPU or memory?**

A: **No!** If you define `limits` for memory, you **must also define CPU limits = requests** (and vice versa) to stay Guaranteed.

**Q: Does Guaranteed mean better performance?**

A: Not necessarily â€” but it means **consistent, predictable** performance under load.

**Q: What about `restartPolicy`?**

A: Guaranteed Pods often use `restartPolicy: Always` (default) to ensure uptime.

---

### ğŸ¯ Pro Tip: Enforce Guaranteed QoS Cluster-Wide

Use **LimitRange** to auto-set `requests = limits` for namespaces:

```yaml
apiVersion: v1
kind: LimitRange
meta
  name: enforce-guaranteed
spec:
  limits:
  - default:
      cpu: "500m"
      memory: "256Mi"
    defaultRequest:
      cpu: "500m"
      memory: "256Mi"
    type: Container

```

â†’ Any Pod without resources gets **Guaranteed** by default!

---

### â¡ï¸ Summary

âœ… **Guaranteed QoS** = `requests == limits` for **all containers, all resources**.

ğŸ›¡ï¸ **Highest priority** â€” never evicted due to resource pressure.

ğŸ” Verify with: `kubectl describe pod | grep "QoS Class"`

ğŸ¯ Use for **critical, predictable workloads** (DBs, agents).

âš ï¸ Requires **more careful capacity planning**.