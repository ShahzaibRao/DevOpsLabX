# 5.2 : Node Selection with `nodeSelector`

https://drive.google.com/file/d/1w8N_GUG-1O1KfFnklYIprM3DNGnZ9p4i/view?usp=sharing

### ğŸ” YAML Breakdown

```yaml
apiVersion: v1
kind: Pod
meta
  name: nnappone
  namespace: learning
  labels:
    app: nnappone
spec:
  containers:
    - name: crackone-app
      image: nginx
      resources:
        requests:
          memory: "300Mi"
        limits:
          memory: "500Mi"
  nodeSelector:
    sku: small   # â† Only run on nodes with label: sku=small

```

> ğŸ”‘ Key Field: spec.nodeSelector: { sku: small }
> 
> 
> â†’ Scheduler will **only consider nodes** that have the label `sku=small`.
> 

---

### ğŸ“Œ How `nodeSelector` Works

| Step | What Happens |
| --- | --- |
| **1. You label nodes** | `kubectl label node <name> sku=small` |
| **2. You deploy Pod** | With `nodeSelector: { sku: small }` |
| **3. Scheduler filters nodes** | Only nodes with `sku=small` are candidates |
| **4. Scheduler scores & picks** | Best node (based on resources, etc.) |
| **5. Pod runs** | On a matching node â€” **no hardcoding!** |

> âœ… Advantages over nodeName:
> 
> - **Portable**: Works on any cluster with labeled nodes
> - **Resilient**: If node fails, Pod reschedules to **another `sku=small` node**
> - **Scalable**: Add more `sku=small` nodes â†’ scheduler uses them automatically

---

### ğŸ§ª Lab: Use `nodeSelector` to Target Labeled Nodes

> ğŸ’¡ Weâ€™ll use Minikube or Kind â€” just label one of your existing nodes.
> 

### ğŸ”§ Step 1: Check & Label a Node

```bash
# 1. See current nodes
kubectl get nodes

# Example output:
# NAME       STATUS   ROLES           AGE   VERSION
# minikube   Ready    control-plane   10m   v1.28.0

# 2. Label your node as "small"
kubectl label node minikube sku=small

# 3. Verify label
kubectl get nodes --show-labels | grep sku
# Should show: minikube ... sku=small

```

### ğŸ”§ Step 2: Deploy the Pod

```bash
# 1. Create namespace
kubectl create namespace learning

# 2. Apply Pod
kubectl apply -f pod-for-specific-node-selector.yml

# 3. Check where it runs
kubectl get pods -n learning -o wide

# âœ… Expected:
# NAME       READY   STATUS    NODE       ...
# nnappone   1/1     Running   minikube   ...

# 4. Describe Pod â†’ confirm nodeSelector
kubectl describe pod nnappone -n learning | grep -A 2 "Node-Selectors"
# Output:
# Node-Selectors:  sku=small

```

### ğŸ”§ Step 3: Clean Up

```bash
# Delete Pod
kubectl delete pod nnappone -n learning

# Remove label (optional)
kubectl label node minikube sku-

# Delete namespace
kubectl delete namespace learning

```

---

### â“ What If No Node Has the Label?

If **no node** has `sku=small`:

```bash
kubectl get pods -n learning
# NAME       READY   STATUS    RESTARTS   AGE
# nnappone   0/1     Pending   0          30s

kubectl describe pod nnappone -n learning
# Events:
#   Warning  FailedScheduling  5s  default-scheduler  0/1 nodes are available: 1 node(s) didn't match Pod's node affinity/selector.

```

> ğŸ” Key Message:
> 
> 
> `"didn't match Pod's node affinity/selector"` â†’ **no node has required label**.
> 

---

### ğŸ†š `nodeName` vs `nodeSelector`

| Feature | `nodeName` | `nodeSelector` |
| --- | --- | --- |
| **Scheduler used?** | âŒ No | âœ… Yes |
| **Resource checks?** | âŒ No | âœ… Yes |
| **Resilient to node failure?** | âŒ No | âœ… Yes |
| **Works with cluster autoscaler?** | âŒ No | âœ… Yes |
| **Production use?** | âŒ Avoid | âœ… Recommended |

> ğŸ¯ Best Practice:
> 
> 
> Always prefer `nodeSelector` (or better: `nodeAffinity`) over `nodeName`.
> 

---

### ğŸ’¡ Real-World Use Cases for `nodeSelector`

| Label | Use Case |
| --- | --- |
| `disktype: ssd` | Run databases on fast storage |
| `zone: us-east-1a` | Place Pods in specific AZ |
| `instance-type: gpu` | Run ML workloads on GPU nodes |
| `environment: prod` | Isolate production workloads |

> ğŸ› ï¸ Pro Tip: Use standardized labels like:
> 
> - `topology.kubernetes.io/zone`
> - `kubernetes.io/os`
> - `node.kubernetes.io/instance-type`

---

### â¡ï¸ Summary

âœ… `nodeSelector` schedules Pods on **nodes with matching labels**.

âœ… Uses **scheduler** â†’ checks resources, taints, capacity.

âœ… **Resilient & portable** â€” ideal for production.

ğŸ” Verify with: `kubectl describe pod` â†’ **"Node-Selectors"** field.

ğŸ› ï¸ Always **label nodes first**: `kubectl label node <name> key=value`.