# 5.7 : Multiple Values in Node Affinity (OR Logic)

https://drive.google.com/file/d/1903si3LmOHSLEYs8V5lBTi4OhmqtRIJn/view?usp=sharing

### ğŸ” YAML Breakdown

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nnappone
  namespace: learning
  labels:
    app: nnappone
spec:
  containers:
    - name: crackone-app
      image: nginx
      resources:
        requests:
          memory: "300Mi"
        limits:
          memory: "500Mi"
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: size
                operator: In
                values:
                  - large
                  - medium  # Pod can run on either "large" or "medium" nodes

```

> ğŸ”‘ Key Insight:
Within a single matchExpressions entry, values: [large, medium] means size IN (large, medium) â†’ logical OR.
ğŸ¯ Rule:
"Schedule this Pod only on nodes where label size is large OR medium."
> 

---

### ğŸ“Œ Affinity Logic Deep Dive

Kubernetes affinity uses a **two-level logic structure**:

| Level | Logic | Purpose |
| --- | --- | --- |
| **`nodeSelectorTerms`** | **OR** between terms | "Match **any** of these sets of conditions" |
| **`matchExpressions`** (inside a term) | **AND** between expressions | "All these conditions must be true" |

> âœ… In your YAML:
> 
> - Only **1 `nodeSelectorTerm`**
> - Inside it: **1 `matchExpression`** with **2 values** â†’ **`size IN (large, medium)`**
> ğŸ’¡ **To express AND**: Add more `matchExpressions` in the same term:
> 
> ```yaml
> matchExpressions:
> - key: size; operator: In; values: [large]
> - key: disk; operator: In; values: [ssd]
> # â†’ Node must have BOTH labels
> 
> ```
> 

---

### ğŸ§ª k3s Lab: Deploy Pod with Multiple Affinity Values

> âœ… Assumption: You have at least 2 worker nodes in your k3s cluster.
> 

### ğŸ”§ Step 1: Label Your k3s Nodes

```bash
# 1. List nodes
kubectl get nodes
# Example:
# NAME STATUS ROLES AGE VERSION
# k3s-master Ready master 2d v1.28.5+k3s1
# k3s-node1 Ready 2d v1.28.5+k3s1
# k3s-node2 Ready 2d v1.28.5+k3s1
# 2. Label nodes with different sizes
kubectl label node k3s-node1 size=small
kubectl label node k3s-node2 size=large
# 3. Verify
kubectl get nodes --show-labels | grep size
# k3s-node1 ... size=small
# k3s-node2 ... size=large

```

### ğŸ”§ Step 2: Deploy the Pod

```bash
# 1. Create namespace
kubectl create namespace learning
# 2. Apply Pod
kubectl apply -f pod-with-node-affinity-multiple.yml
# 3. Check placement
kubectl get pods -n learning -o wide
# âœ… Expected: Runs on k3s-node2 (size=large)
# âŒ Will NOT run on k3s-node1 (size=small â€” not in [large, medium])

```

### ğŸ”§ Step 3: Test Failure (No Matching Node)

> ğŸ’¡ Temporarily remove the large label to simulate no match.
> 

```bash
# 1. Remove label from k3s-node2
kubectl label node k3s-node2 size-
# 2. Deploy again
kubectl apply -f pod-with-node-affinity-multiple.yml
# 3. Check status
kubectl get pods -n learning
# â†’ STATUS = Pending
# 4. Describe to confirm
kubectl describe pod nnappone -n learning
# Events: 0/2 nodes match node affinity

```

### ğŸ”§ Step 4: Clean Up

```bash
kubectl delete pod nnappone -n learning
kubectl label node k3s-node1 size-
kubectl label node k3s-node2 size-
kubectl delete namespace learning

```

---

### ğŸ†š Real-World Use Cases

| Scenario | Affinity Rule |
| --- | --- |
| **Avoid small nodes** | `size IN (medium, large, xlarge)` |
| **Multi-AZ redundancy** | `zone IN (us-east-1a, us-east-1b)` |
| **GPU or CPU-only** | `accelerator IN (nvidia-tesla-v100, none)` |

> âœ… Pro Tip: Use standard labels like:
> 
> - `topology.kubernetes.io/zone`
> - `node.kubernetes.io/instance-type`
> - `kubernetes.io/arch`

---

### â“ Common Questions

**Q: What if I want `size=large` AND `disk=ssd`?**
A: Add **multiple `matchExpressions`** in the same term:

```yaml
matchExpressions:
- key: size
operator: In
values: [large]
- key: disk
operator: In
values: [ssd]

```

**Q: Can I mix `required` and `preferred` affinity?**
A: âœ… Yes! They work together:

- `required` â†’ hard filter (must match)
- `preferred` â†’ soft scoring (after filtering)
**Q: Whatâ€™s the difference between `values: [A, B]` and two separate `matchExpressions`?**
A:
- `values: [A, B]` â†’ **OR**: `key IN (A, B)`
- Two `matchExpressions` â†’ **AND**: `key1=A AND key2=B`**Q: Does order of `values` matter?**
A: âŒ No. `[large, medium]` = `[medium, large]`.
**Q: Can I use `NotIn` with multiple values?**
A: âœ… Yes! Example: avoid small/medium:

```yaml
operator: NotIn
values: [small, medium]
# â†’ Only runs on large/xlarge/etc.

```

---

### â¡ï¸ Summary

## âœ… **`values: [large, medium]`** = **logical OR** (`size IN (large, medium)`).
âœ… Use **single `matchExpressions`** for **OR on one label**.
âœ… Use **multiple `matchExpressions`** for **AND across labels**.
âœ… **`nodeSelectorTerms`** = **OR between groups of conditions**.
ğŸ” In k3s: Works identically to upstream Kubernetes â€” perfect for multi-node testing.