# 5.9 : Pod Priority & Preemption

https://drive.google.com/file/d/1lnSO1RKmS6n6JtSRh9jsYmmg2EbxfWrH/view?usp=sharing

### ğŸ” Part 1: PriorityClass Definition

```yaml
# mission-critical-priority-class.yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
meta
  name: mission-critical-apps
value: 1000000                 # â† Higher = more important
preemptionPolicy: Never        # â† Key setting!
globalDefault: false
description: "For mission-critical apps"

```

> ğŸ”‘ Key Fields:
> 
> - **`value`**: Priority score (1 to 1,000,000,000). **Higher = scheduled first**.
> - **`preemptionPolicy`**:
>     - `PreemptLowerPriority` (default): **Evict lower-priority Pods** to make room
>     - `Never`: **Donâ€™t evict** â€” just wait in queue (your example)
> - **`globalDefault: false`**: Donâ€™t apply to Pods without `priorityClassName`

> ğŸ’¡ Default Critical Classes (built into Kubernetes):
> 
> - `system-cluster-critical` â†’ `value: 2000000000` (CoreDNS, CNI, Metrics Server)
> - `system-node-critical` â†’ `value: 2000001000` (etcd, kubelet, API server)

---

### ğŸ” Part 2: Pod Using PriorityClass

```yaml
# mission-critical-pod.yaml
apiVersion: v1
kind: Pod
meta
  name: topgun
  labels:
    app: topgun
    env: prod
spec:
  containers:
  - name: boxone
    image: nginx
    imagePullPolicy: IfNotPresent
  priorityClassName: mission-critical-apps  # â† Links to PriorityClass

```

> âœ… This Pod will:
> 
> - Be placed **ahead of lower-priority Pods** in scheduling queue
> - **NOT preempt** others (because `preemptionPolicy: Never`)
> - Wait **indefinitely** if no resources are available

---

### ğŸ“Œ How Priority & Preemption Work

| Scenario | Behavior |
| --- | --- |
| **Resources available** | High-priority Pod schedules **immediately** |
| **No resources, `preemptionPolicy: PreemptLowerPriority`** | Scheduler **evicts lowest-priority Pods** to free space |
| **No resources, `preemptionPolicy: Never`** | Pod **waits in queue** â€” no eviction |
| **All Pods have same priority** | First-come, first-served |

> âš ï¸ Preemption is a last resort â€” scheduler tries to find space without eviction first.
> 

---

### ğŸ§ª k3s Lab: Priority & Preemption in Action

> âœ… Assumption: Your k3s cluster has limited CPU/memory (or weâ€™ll simulate scarcity).
> 

### ğŸ”§ Step 1: Create PriorityClass

```bash
# Save as mission-critical-priority-class.yaml
cat <<EOF | kubectl apply -f -
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
meta
  name: mission-critical-apps
value: 1000000
preemptionPolicy: PreemptLowerPriority  # â† Changed to test preemption!
globalDefault: false
description: "For mission-critical apps"
EOF

```

> ğŸ’¡ We set preemptionPolicy: PreemptLowerPriority to see eviction in action.
> 

### ğŸ”§ Step 2: Deploy Low-Priority "Filler" Pods

> ğŸ’¡ Fill your cluster so no room is left for new Pods.
> 

```bash
# Deploy 2 low-priority Pods that consume resources
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
meta
  name: filler-1
spec:
  containers:
  - name: stress
    image: lovelearnlinux/stress:latest
    resources:
      requests:
        memory: "400Mi"
        cpu: "500m"
    command: ["stress"]
    args: ["--vm", "1", "--vm-bytes", "300M"]
---
apiVersion: v1
kind: Pod
meta
  name: filler-2
spec:
  containers:
  - name: stress
    image: lovelearnlinux/stress:latest
    resources:
      requests:
        memory: "400Mi"
        cpu: "500m"
    command: ["stress"]
    args: ["--vm", "1", "--vm-bytes", "300M"]
EOF

```

> ğŸ“Š Check resource usage:
> 
> 
> ```bash
> kubectl top nodes
> # Ensure nodes are near capacity
> 
> ```
> 

### ğŸ”§ Step 3: Deploy High-Priority Pod

```bash
# Save as mission-critical-pod.yaml
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
meta
  name: topgun
  labels:
    app: topgun
    env: prod
spec:
  containers:
  - name: nginx
    image: nginx
    resources:
      requests:
        memory: "300Mi"
        cpu: "300m"
  priorityClassName: mission-critical-apps
EOF

```

### ğŸ”§ Step 4: Observe Preemption

```bash
# Watch Pods
kubectl get pods -w

# âœ… Expected:
# - One of `filler-1` or `filler-2` gets **terminated**
# - `topgun` becomes **Running**

# Check events
kubectl describe pod topgun
# Events: Successfully assigned...

# Check evicted Pod
kubectl get pods
# filler-1   0/1   Terminated   0     2m

```

> ğŸ” Why only one filler evicted?
> 
> 
> Scheduler calculates: *"Evicting one filler frees enough resources for `topgun`."*
> 

### ğŸ”§ Step 5: Clean Up

```bash
kubectl delete pod topgun filler-1 filler-2
kubectl delete priorityclass mission-critical-apps

```

---

### ğŸ’¡ Real-World Use Cases

| Priority Level | Use Case |
| --- | --- |
| **`system-node-critical`** | etcd, kube-apiserver |
| **`system-cluster-critical`** | CoreDNS, CNI, Metrics Server |
| **Custom High (1,000,000+)** | Payment processing, real-time trading |
| **Medium (10,000)** | User-facing web apps |
| **Low (100)** | Batch jobs, log processors |

> âœ… Best Practice:
> 
> - Use `preemptionPolicy: Never` for **critical apps** (donâ€™t cause collateral damage)
> - Use `PreemptLowerPriority` for **urgent but non-critical** workloads

---

### â“ Common Questions

**Q: Are PriorityClasses namespaced?**

A: âŒ **No!** Theyâ€™re **cluster-scoped** â€” available to all namespaces.

**Q: What if two Pods have same priority?**

A: Scheduled in **creation timestamp order** (FIFO).

**Q: Can I change a Podâ€™s priority after creation?**

A: âŒ **No!** Priority is set at creation and **immutable**.

**Q: Does preemption respect PodDisruptionBudgets (PDB)?**

A: âœ… **Yes!** Scheduler **wonâ€™t preempt** if it violates a PDB.

**Q: Is priority enabled by default in k3s?**

A: âœ… **Yes!** k3s enables the **`PodPriority`** feature gate by default.

---

### â¡ï¸ Summary

âœ… **PriorityClass** = cluster-wide priority definition

âœ… **Higher `value`** = scheduled sooner

âœ… **`preemptionPolicy`** controls eviction behavior

âœ… **Critical system Pods** use built-in high-priority classes

ğŸ” In k3s: Works out-of-the-box â€” perfect for testing