# 6.3 : Production-Ready Declarative Deployment

https://drive.google.com/file/d/1Mq5KYEMXCQpTEUPk2sIZfgXHgbiTcq-X/view?usp=sharing

### ğŸ” Current YAML Breakdown

```yaml
apiVersion: apps/v1
kind: Deployment
meta
  name: nginx-declarative
  annotations:
    environment: prod
    organization: sales
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx          # â† Good: uses standard 'app' label
  template:
    meta
      labels:
        app: nginx         # â† Must match selector
    spec:
      containers:
      - name: nginx
        image: nginx:latest  # âš ï¸ Problem!

```

> âœ… Whatâ€™s Good:
> 
> - Uses **standard `app` label** (better than `run`)
> - Includes **annotations** for metadata
> - Clean, version-controllable YAML

> âš ï¸ Whatâ€™s Missing (vs deployment-one.yml):
> 
> 1. **`:latest` tag** â†’ non-deterministic
> 2. **No resource requests/limits** â†’ canâ€™t use HPA, poor scheduling
> 3. **No liveness/readiness probes** â†’ no health checks
> 4. **No update strategy** â†’ uses default (`maxSurge: 25%`, `maxUnavailable: 25%`)
> 5. **No ports declaration** â†’ optional but good practice

---

### ğŸ› ï¸ Enhanced Production-Ready Version

Hereâ€™s how to **upgrade** this for production:

```yaml
# declarative-deployment.yaml (ENHANCED)
apiVersion: apps/v1
kind: Deployment
meta
  name: nginx-declarative
  annotations:
    environment: prod
    organization: sales
    kubernetes.io/change-cause: "nginx 1.25 with health checks"
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1          # +1 extra during update
      maxUnavailable: 0    # zero downtime
  selector:
    matchLabels:
      app: nginx
  template:
    meta
      labels:
        app: nginx
        version: v1.25     # â† Optional: track version in labels
    spec:
      containers:
      - name: nginx
        image: nginx:1.25-alpine  # âœ… Specific, lightweight tag
        ports:
        - containerPort: 80
          name: http
        resources:
          requests:
            cpu: "100m"
            memory: "128Mi"
          limits:
            cpu: "200m"
            memory: "256Mi"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 10
          periodSeconds: 20
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 10

```

> âœ… Key Improvements:
> 
> - **Specific image tag** (`1.25-alpine`)
> - **Resource requests/limits**
> - **Liveness + Readiness probes**
> - **Zero-downtime strategy**
> - **Standardized labels**

---

### ğŸ§ª k3s Lab: Deploy & Compare

### ğŸ”§ Step 1: Deploy the Basic Version

```bash
# Apply basic declarative Deployment
kubectl apply -f declarative-deployment.yaml

# Check Pods
kubectl get pods -l app=nginx

```

### ğŸ”§ Step 2: Upgrade to Enhanced Version

> ğŸ’¡ Save the enhanced YAML as declarative-deployment-enhanced.yaml
> 

```bash
kubectl apply -f declarative-deployment-enhanced.yaml

# Watch zero-downtime rollout
kubectl rollout status deployment nginx-declarative

```

### ğŸ”§ Step 3: Verify Health Checks

```bash
# Simulate app crash (delete index.html)
kubectl exec <pod-name> -- rm /usr/share/nginx/html/index.html

# Watch liveness probe fail â†’ container restart
kubectl describe pod <pod-name> | grep -A 5 "Liveness"

```

### ğŸ”§ Step 4: Clean Up

```bash
kubectl delete deployment nginx-declarative

```

---

### ğŸ†š Imperative vs Declarative: Final Comparison

| Task | Imperative | Declarative |
| --- | --- | --- |
| **Create** | `kubectl create deployment ...` | `kubectl apply -f deployment.yaml` |
| **Scale** | `kubectl scale --replicas=3` | Edit `replicas: 3` in YAML â†’ `apply` |
| **Update Image** | `kubectl set image deployment/nginx nginx=nginx:1.25` | Edit YAML â†’ `apply` |
| **Add Probes** | âŒ Very hard | âœ… Edit YAML â†’ `apply` |
| **GitOps** | âŒ Impossible | âœ… Native support |

> ğŸ¯ Best Practice:
> 
> 
> Use **imperative for learning**, **declarative for everything else**.
> 

---

### ğŸ’¡ Pro Tips for k3s

1. **Always specify resource requests** â†’ k3s clusters are often resource-constrained.
2. **Use `alpine` images** â†’ smaller, faster, more secure.
3. **Add `readinessProbe`** â†’ prevents sending traffic to unready Pods (critical for Services).
4. **Version your Deployments** â†’ use Git tags or ArgoCD.

---

### â“ Common Questions

**Q: Can I use `kubectl apply` with imperative-created objects?**

A: âœ… Yes! But **donâ€™t mix** â€” once you `apply`, stick to YAML.

**Q: What if I forget `selector.matchLabels`?**

A: Kubernetes **auto-generates** it from `template.labels` â€” but **explicit is better**.

**Q: Are annotations required?**

A: âŒ No â€” but theyâ€™re great for **team metadata** (owner, env, cost center).

**Q: Why `app: nginx` and not `app.kubernetes.io/name: nginx`?**

A: Both work! But [Kubernetes recommends](https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/) the latter for production:

```yaml
labels:
  app.kubernetes.io/name: nginx
  app.kubernetes.io/instance: nginx-prod
  app.kubernetes.io/version: "1.25"

```

---

### â¡ï¸ Summary

âœ… **Declarative YAML** = **production standard**

âš ï¸ **Avoid `:latest`** â€” use specific tags

âœ… **Add probes, resources, strategies** for resilience

ğŸ” **Enhance basic Deployments** with production features

ğŸ› ï¸ **Use Git to version-control** your YAML