# 6.6: Deployment + Service (Internal Networking)

https://drive.google.com/file/d/15f1qmvb0fFdgfy36AyHULdF8q7y14OP1/view?usp=sharing

### üîç YAML Breakdown

```yaml
# deployment-webserver-with-service.yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nn-web
  namespace: learning
spec:
  selector:
    matchLabels:
      run: nn-web          # ‚Üê Must match Pod template labels
  replicas: 2
  template:
    metadata:
      labels:
        run: nn-web         # ‚Üê Labels for Pods
    spec:
      containers:
      - name: nn-webserver
        image: lovelearnlinux/webserver:v1
        ports:
        - containerPort: 80  # ‚Üê Good practice (though optional)

```

> üîë Key Insight:
> 
> 
> This YAML **only defines the Deployment**.
> 
> The **Service is created separately** via:
> 
> ```bash
> kubectl expose deployment/nn-web --namespace=learning
> 
> ```
> 

---

### üìå How Kubernetes Services Work

| Component | Role |
| --- | --- |
| **Deployment** | Manages **replicated Pods** with label `run=nn-web` |
| **Service** | Provides a **stable IP/DNS name** to access those Pods |
| **Selector** | `run=nn-web` ‚Üí **links Service to Pods** |
| **Endpoints** | Auto-generated list of **Pod IPs** that match the selector |

> üéØ Flow:
> 
> 
> `curl <http://nn-web.learning.svc.cluster.local`>
> 
> ‚Üí Service (ClusterIP)
> 
> ‚Üí **Random Pod** with `run=nn-web` label
> 

---

### üß™ k3s Lab: Deploy + Service + Test Connectivity

### üîß Step 1: Create Namespace & Deploy

```bash
# Create namespace
kubectl create namespace learning

# Apply Deployment
kubectl apply -f deployment-webserver-with-service.yml

# Verify Pods
kubectl get pods -n learning -l run=nn-web -o wide

```

### üîß Step 2: Expose as Service

```bash
# Create ClusterIP Service (default)
kubectl expose deployment/nn-web --port=80 --target-port=80 -n learning

# Verify Service
kubectl get svc nn-web -n learning
# NAME     TYPE        CLUSTER-IP      PORT(S)
# nn-web   ClusterIP   10.43.123.45    80/TCP

# Check Endpoints (Pod IPs)
kubectl get endpoints nn-web -n learning
# NAME     ENDPOINTS                         AGE
# nn-web   10.42.0.10:80,10.42.1.15:80       10s

```

> üîç --port=80 = Service port
> 
> - **`-target-port=80`** = Pod port (matches `containerPort`)

### üîß Step 3: Test Connectivity

> üí° In k3s, you can curl from any node or from a debug Pod.
> 

### Option A: Test from a Temporary Debug Pod

```bash
# Start a debug Pod in the same namespace
kubectl run debug -n learning --image=curlimages/curl -it --rm -- sh

# Inside the shell:
curl <http://nn-web>
# ‚úÖ Should return "Welcome to Network Nuts!"

# Exit
exit

```

### Option B: Test from a k3s Node (SSH into node)

```bash
# On any k3s node:
curl http://<CLUSTER-IP>
# Example: curl <http://10.43.123.45>

```

> ‚úÖ Both methods work because:
> 
> - ClusterIP is **routable from all Pods**
> - k3s configures **kube-proxy** to handle node access

### üîß Step 4: Clean Up

```bash
kubectl delete deployment nn-web -n learning
kubectl delete service nn-web -n learning
kubectl delete namespace learning

```

---

### üí° Key Concepts Clarified

### 1. **Why `kubectl expose`?**

- Creates a **Service** that **selects Pods** by the Deployment‚Äôs labels (`run=nn-web`)
- Equivalent to this YAML:
    
    ```yaml
    apiVersion: v1
    kind: Service
    meta
      name: nn-web
      namespace: learning
    spec:
      selector:
        run: nn-web    # ‚Üê Must match Pod labels
      ports:
      - port: 80       # Service port
        targetPort: 80 # Pod port
    
    ```
    

### 2. **Service DNS**

- From any Pod in the cluster:
    
    ```bash
    curl <http://nn-web.learning.svc.cluster.local>
    
    ```
    
- Short form (same namespace): `curl <http://nn-web`>

### 3. **Stable Endpoints**

- If a Pod dies, **Endpoints auto-update** ‚Üí zero config change needed!

---

### üÜö Service Types (Preview)

| Type | Use Case | Access |
| --- | --- | --- |
| **`ClusterIP`** (default) | Internal cluster communication | Only from inside cluster |
| **`NodePort`** | External access (dev/testing) | `http://<NODE-IP>:30000-32767` |
| **`LoadBalancer`** | Cloud external IP | Cloud provider assigns public IP |
| **`ExternalName`** | CNAME to external service | Returns CNAME record |

> üí° Your lab uses ClusterIP ‚Äî perfect for internal microservices.
> 

---

### ‚ùì Common Questions

**Q: What if Service selector doesn‚Äôt match any Pods?**

A: Service exists, but **Endpoints = `<none>`** ‚Üí connections **time out**.

**Q: Can I use a different label for Service vs Deployment?**

A: ‚úÖ Yes! Just ensure **Pods have the Service‚Äôs label**:

```yaml
# Pod labels
labels:
  app: web
  env: prod

# Service selector
selector:
  app: web   # ‚Üê Will match

```

**Q: Why declare `containerPort` if Service uses `targetPort`?**

A: `containerPort` is **documentation only** ‚Äî but **best practice** for clarity.

**Q: Does k3s support LoadBalancer?**

A: ‚úÖ With **MetalLB** or **cloud provider**. By default, only `ClusterIP`/`NodePort`.

---

### ‚û°Ô∏è Summary

‚úÖ **Service** = stable endpoint for **dynamic Pods**

‚úÖ **Selector** (`run=nn-web`) links Service to Pods

‚úÖ **Endpoints** = auto-updated list of Pod IPs

üîç In k3s: Test with **debug Pod** or **node curl**

üõ†Ô∏è Use `kubectl expose` for quick Services, YAML for production