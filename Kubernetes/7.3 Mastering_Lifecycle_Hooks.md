# 7.3: Pod Lifecycle Hooks (`postStart` & `preStop`)

https://drive.google.com/file/d/1HKmo-R__r1_zY8mbeMExjsTqKts86_x2/view?usp=sharing

### ğŸ” YAML Breakdown

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nnappone
  namespace: learning
  labels:
    app: nnappone
spec:
  containers:
    - name: crackone-app
      image: lovelearnlinux/webserver:v1
      lifecycle:
        postStart:
          exec:
            command: ["/bin/sh", "-c", "useradd crackone -p redhat"]
        preStop:
          exec:
            command: ["/bin/sh","-c","rm -rf /home/crackone; userdel crackone"]

```

> ğŸ”‘ Key Insight:
> 
> - **`postStart`**: Runs **immediately after container starts** (but **not guaranteed** to run before app starts!)
> - **`preStop`**: Runs **immediately before container terminates** (graceful shutdown)

> âš ï¸ Critical Note:
> 
> 
> `postStart` runs **asynchronously** with the containerâ€™s main process.
> 
> â†’ Your app might start **before** `postStart` finishes!
> 

---

### ğŸ“Œ When Lifecycle Hooks Run

| Hook | When It Runs | Use Cases |
| --- | --- | --- |
| **`postStart`** | After container is created, **before** app fully starts | - Create users/dirs<br>- Fetch config from remote<br>- Send startup notification |
| **`preStop`** | **Before** container is terminated (during `SIGTERM`) | - Drain connections<br>- Flush logs<br>- Cleanup temp files |

> ğŸ¯ Your Example:
> 
> - `postStart`: Creates a user `crackone`
> - `preStop`: Deletes the user and home directory

> ğŸ’¡ Why preStop matters:
> 
> 
> Without it, user data would **linger** after Pod deletion (in container filesystem).
> 

---

### ğŸ§ª k3s Lab: Observe Lifecycle Hooks

### ğŸ”§ Step 1: Create Namespace & Deploy Pod

```bash
# Create namespace
kubectl create namespace learning

# Apply Pod
kubectl apply -f pod-simple-lifecycle-events.yml

# Wait for Pod to be ready
kubectl get pods -n learning

```

### ğŸ”§ Step 2: Verify `postStart` Ran

```bash
# Check if user was created
kubectl exec nnappone -n learning -- cat /etc/passwd | grep crackone

# âœ… Expected output:
# cracokone:x:1001:1001::/home/crackone:/bin/sh

# Check home directory
kubectl exec nnappone -n learning -- ls /home
# crackone

```

### ğŸ”§ Step 3: Trigger `preStop` (Delete Pod)

```bash
# Delete Pod (triggers preStop)
kubectl delete pod nnappone -n learning

# Watch termination
kubectl get pods -n learning -w

```

> ğŸ” How to verify preStop ran?
> 
> 
> Since the Pod is deleted, we canâ€™t check directly.
> 
> But we can **test with a long-running `preStop`**:
> 

### ğŸ”§ Step 4: Test `preStop` with Delay (Optional)

> ğŸ’¡ Modify preStop to sleep (so you can observe it):
> 

```yaml
preStop:
  exec:
    command: ["/bin/sh","-c","sleep 10; rm -rf /home/crackone; userdel crackone"]

```

```bash
# Apply modified Pod
kubectl apply -f pod-lifecycle-with-sleep.yaml

# Delete Pod and time termination
time kubectl delete pod nnappone -n learning
# real    0m10.234s  â† Matches sleep 10s!

```

> âœ… Proof: preStop ran and delayed termination.
> 

### ğŸ”§ Step 5: Clean Up

```bash
kubectl delete namespace learning

```

---

### ğŸ’¡ Real-World Lifecycle Hook Examples

| Hook | Example Command |
| --- | --- |
| **`postStart`** | `curl -o /app/config.json <http://config-server/config`> |
| **`postStart`** | `mkdir -p /app/logs && chown appuser /app/logs` |
| **`preStop`** | `nginx -s quit` (graceful Nginx shutdown) |
| **`preStop`** | `redis-cli shutdown` (save RDB before exit) |
| **`preStop`** | `aws sns publish --message "Pod terminating"` |

> âœ… Best Practices:
> 
> - **Keep `postStart` fast** â†’ delays app startup
> - **Make `preStop` idempotent** â†’ may run multiple times
> - **Always test termination** â†’ ensure cleanup works

---

### âš ï¸ Critical Limitations

1. **`postStart` is not blocking**:
    
    Main container process **starts immediately** â€” donâ€™t assume `postStart` finished!
    
2. **`preStop` has a deadline**:
    
    If `preStop` runs longer than `terminationGracePeriodSeconds` (default: 30s), Kubernetes sends `SIGKILL`.
    
3. **No retries**:
    
    If hook fails, Kubernetes **logs error but continues**.
    

> ğŸ› ï¸ Fix for postStart race condition:
> 
> 
> Move setup logic **into your appâ€™s startup script** instead.
> 

---

### â“ Common Questions

**Q: What if `postStart` fails?**

A: Pod stays **`Running`**, but logs show error. **No restart** (unlike liveness probe).

**Q: Can I use `httpGet` in lifecycle hooks?**

A: âŒ **No!** Only `exec` is supported for lifecycle hooks.

**Q: Does `preStop` run during node failure?**

A: âŒ **No!** Only during **graceful termination** (e.g., `kubectl delete`, scale-down).

âœ… **For node failures**, rely on **PodDisruptionBudgets** and **replication**.

**Q: How to debug hook failures?**

A: Check Pod events:

```bash
kubectl describe pod <pod> -n learning | grep -A 5 "Lifecycle"

```

---

### â¡ï¸ Summary

âœ… **`postStart`** = run logic **after container starts** (setup)

âœ… **`preStop`** = run logic **before container stops** (cleanup)

âš ï¸ **`postStart` is async** â†’ donâ€™t rely on it for critical startup

ğŸ” In k3s: Test with `useradd`/`userdel` or `sleep` in `preStop`