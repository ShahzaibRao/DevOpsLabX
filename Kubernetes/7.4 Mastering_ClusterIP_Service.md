# 7.4: ClusterIP Service (Internal Networking)

https://drive.google.com/file/d/1zDHaAE6VSwacb2Z4Bj1tgvMY2ZysmrDO/view?usp=sharing

### ğŸ” YAML Breakdown

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nnappone-service
spec:
  selector:
    app: nnappone          # â† Must match Pod labels
  ports:
    - protocol: TCP
      port: 8080           # â† Service port (what clients connect to)
      targetPort: 80       # â† Pod port (where app listens)

```

> ğŸ”‘ Key Insight:
> 
> 
> This Service creates a **stable virtual IP** (`ClusterIP`) that **load-balances traffic** to **all Pods with label `app: nnappone`**.
> 

---

### ğŸ“Œ How ClusterIP Services Work

| Component | Role |
| --- | --- |
| **`selector`** | Links Service to Pods (`app: nnappone`) |
| **`port: 8080`** | Port exposed by the **Service** |
| **`targetPort: 80`** | Port exposed by the **Pod** (matches `containerPort`) |
| **`ClusterIP`** | Virtual IP (e.g., `10.43.x.x`) â€” only reachable **inside the cluster** |

> ğŸ¯ Flow:
> 
> 
> `curl http://nnappone-service:8080`
> 
> â†’ Service (`10.43.x.x:8080`)
> 
> â†’ **Random Pod** with `app: nnappone` â†’ `:80`
> 

> ğŸ’¡ DNS:
> 
> 
> From any Pod in the same namespace:
> 
> ```bash
> curl <http://nnappone-service>  # Port 8080 by default
> 
> ```
> 
> From other namespaces:
> 
> ```bash
> curl <http://nnappone-service.default.svc.cluster.local>
> 
> ```
> 

---

### ğŸ§ª k3s Lab: Deploy Pod + Service + Test Connectivity

### ğŸ”§ Step 1: Deploy a Pod with Matching Label

> ğŸ’¡ You need a Pod with app: nnappone label (from earlier chapters):
> 

```yaml
# pod-for-service.yaml
apiVersion: v1
kind: Pod
meta
  name: nnappone
  labels:
    app: nnappone          # â† Must match Service selector
spec:
  containers:
  - name: web
    image: nginx
    ports:
    - containerPort: 80

```

```bash
# Apply Pod
kubectl apply -f pod-for-service.yaml

# Apply Service
kubectl apply -f service-for-pod.yml

```

### ğŸ”§ Step 2: Verify Service Endpoints

```bash
# Check if Service found the Pod
kubectl get endpoints nnappone-service

# âœ… Expected:
# NAME                 ENDPOINTS         AGE
# nnappone-service     10.42.0.10:80     10s

# âŒ If ENDPOINTS = <none> â†’ label mismatch!

```

### ğŸ”§ Step 3: Test Connectivity

### Option A: From a Temporary Debug Pod (Inside Cluster)

```bash
# Start debug Pod
kubectl run debug --image=curlimages/curl -it --rm -- sh

# Inside shell:
curl <http://nnappone-service:8080>
# âœ… Should return "Welcome to Network Nuts!"

# Exit
exit

```

### Option B: From k3s Node (If Needed)

> ğŸ’¡ ClusterIP is NOT reachable from outside the cluster by default.
> 
> 
> But in k3s, you can access it **from node host** (due to kube-proxy):
> 

```bash
# On any k3s node:
curl http://<CLUSTER-IP>:8080
# Get CLUSTER-IP with: kubectl get svc nnappone-service

```

> âš ï¸ Not recommended for production â€” use NodePort or Ingress for external access.
> 

### ğŸ”§ Step 4: Clean Up

```bash
kubectl delete pod nnappone
kubectl delete svc nnappone-service

```

---

### ğŸ’¡ Key Concepts Clarified

### 1. **Why `port: 8080` and `targetPort: 80`?**

- Allows **decoupling** Service port from Pod port
- Example: Expose legacy app (`:8080`) as standard HTTP (`:80`)

### 2. **What if no Pods match the selector?**

- Service exists, but **Endpoints = `<none>`**
- Connections **time out** (no "no route to host" error)

### 3. **How does load balancing work?**

- **iptables** or **IPVS** (in k3s) â†’ random Pod selection
- **No session affinity** by default (use `sessionAffinity: ClientIP` if needed)

---

### ğŸ†š Service Types (k3s Context)

| Type | Use Case | Access |
| --- | --- | --- |
| **`ClusterIP`** (default) | Internal microservices | Only from inside cluster |
| **`NodePort`** | External access (dev/testing) | `http://<NODE-IP>:30000-32767` |
| **`LoadBalancer`** | Cloud external IP | Requires MetalLB in k3s |

> ğŸ’¡ Your YAML creates a ClusterIP Service â€” perfect for internal communication.
> 

---

### â“ Common Questions

**Q: Whatâ€™s the difference between `port` and `targetPort`?**

A:

- **`port`**: What the **Service listens on**
- **`targetPort`**: What the **Pod listens on**

**Q: Can I use a name for `targetPort`?**

A: âœ… Yes! If Pod defines a port name:

```yaml
ports:
- name: http
  containerPort: 80

```

Then Service can use:

```yaml
targetPort: http

```

**Q: Does the Service IP ever change?**

A: âŒ **No!** `ClusterIP` is **stable for the life of the Service**.

**Q: How many Services can I create?**

A: Limited by **cluster IP range** (default: ~65k IPs in k3s).

---

### â¡ï¸ Summary

âœ… **`ClusterIP` Service** = stable internal endpoint for Pods

âœ… **`selector` must match Pod labels**

âœ… **`port` â‰  `targetPort`** â†’ decouples Service from Pod

ğŸ” In k3s: Test with **debug Pod** (`curl http://<service>:<port>`)

ğŸ› ï¸ Always verify with **`kubectl get endpoints`**