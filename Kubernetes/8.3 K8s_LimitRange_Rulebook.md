# 8.3: LimitRange (Default & Enforced Resource Constraints)

https://drive.google.com/file/d/1QTMUPUBy1ik_fnO0AaGF0wPUCn3faDqE/view?usp=sharing

### ğŸ” YAML Breakdown

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: def-cpu-mem-limit
  namespace: dev
spec:
  limits:
  - default:              # â† Applied if Pod defines NO limits
      cpu: 111m
      memory: 99Mi
    defaultRequest:       # â† Applied if Pod defines NO requests
      cpu: 101m
      memory: 91Mi
    max:                  # â† Hard ceiling (enforced)
      cpu: 200m
      memory: 100Mi
    min:                  # â† Hard floor (enforced)
      cpu: 100m
      memory: 90Mi
    type: Container

```

> ğŸ”‘ Key Insight:
> 
> 
> This LimitRange does **two critical things**:
> 
> 1. **Auto-applies defaults** to Pods that donâ€™t define resources
> 2. **Enforces min/max** on Pods that *do* define resources

> ğŸ’¡ Why this matters:
> 
> - Without defaults â†’ Pods are **BestEffort** (lowest priority, first to evict)
> - Without min/max â†’ Teams can request **1000 CPUs** and break quotas

---

### ğŸ“Œ How LimitRange Works

| Scenario | Behavior |
| --- | --- |
| **Pod defines NO resources** | â†’ `defaultRequest` + `default` applied |
| **Pod defines resources within min/max** | â†’ Podâ€™s values used |
| **Pod defines resources BELOW min** | â†’ **Rejected** (`exceeds min limit`) |
| **Pod defines resources ABOVE max** | â†’ **Rejected** (`exceeds max limit`) |

> ğŸ¯ Your Rules:
> 
> - **CPU**: `100m â‰¤ request â‰¤ 200m`, `111m â‰¤ limit â‰¤ 200m`
> - **Memory**: `90Mi â‰¤ request â‰¤ 100Mi`, `99Mi â‰¤ limit â‰¤ 100Mi`

> âš ï¸ Critical Note:
> 
> 
> `defaultRequest` **must be â‰¤ `default`** (your example: `101m â‰¤ 111m` â†’ âœ… valid)
> 

---

### ğŸ§ª k3s Lab: Test LimitRange Behavior

### ğŸ”§ Step 1: Create Namespace & Apply LimitRange

```bash
# Create namespace
kubectl create namespace dev

# Apply LimitRange
kubectl apply -f limit-ranges.yaml

# Verify
kubectl describe limitrange def-cpu-mem-limit -n dev

```

### ğŸ”§ Step 2: Test Case 1 â€” Pod with NO Resources

```yaml
# pod-no-resources.yaml
apiVersion: v1
kind: Pod
metadata:
  name: no-res-pod
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx

```

```bash
kubectl apply -f pod-no-resources.yaml

# Check applied resources
kubectl get pod no-res-pod -n dev -o jsonpath='{.spec.containers[0].resources}'
# âœ… Output:
# {"limits":{"cpu":"111m","memory":"99Mi"},
#  "requests":{"cpu":"101m","memory":"91Mi"}}

```

> ğŸ” Result:
> 
> 
> LimitRange **auto-applied defaults** â†’ Pod is **Burstable** (not BestEffort)!
> 

### ğŸ”§ Step 3: Test Case 2 â€” Pod Within Min/Max

```yaml
# pod-valid-resources.yaml
apiVersion: v1
kind: Pod
metadata:
  name: valid-pod
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx
    resources:
      requests:
        cpu: "150m"
        memory: "95Mi"
      limits:
        cpu: "180m"
        memory: "100Mi"

```

```bash
kubectl apply -f pod-valid-resources.yaml
# âœ… Success! Resources within min/max.

```

### ğŸ”§ Step 4: Test Case 3 â€” Pod Exceeds Max

```yaml
# pod-exceeds-max.yaml
apiVersion: v1
kind: Pod
metadata:
  name: bad-pod
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx
    resources:
      requests:
        cpu: "300m"   # > max 200m!
      limits:
        cpu: "400m"

```

```bash
kubectl apply -f pod-exceeds-max.yaml

# âœ… Expected error:
# Error from server (Forbidden):
# [containers "nginx" is forbidden:
# cpu request 300m is more than the max limit 200m]

```

### ğŸ”§ Step 5: Clean Up

```bash
kubectl delete pod --all -n dev
kubectl delete limitrange def-cpu-mem-limit -n dev
kubectl delete namespace dev

```

---

### ğŸ’¡ Real-World LimitRange Strategies

| Environment | Min | DefaultRequest | Default | Max |
| --- | --- | --- | --- | --- |
| **Production** | 500m/512Mi | 1000m/1Gi | 2000m/2Gi | 4000m/4Gi |
| **Development** | 100m/128Mi | 200m/256Mi | 500m/512Mi | 1000m/1Gi |
| **Sandbox** | 50m/64Mi | 100m/128Mi | 200m/256Mi | 500m/512Mi |

> âœ… Best Practices:
> 
> - **Always set `min`/`max`** to prevent abuse
> - **Set `defaultRequest` â‰ˆ average usage**, `default` â‰ˆ peak usage
> - **Combine with ResourceQuota** for complete governance

---

### ğŸ†š LimitRange vs ResourceQuota

| Feature | **LimitRange** | **ResourceQuota** |
| --- | --- | --- |
| **Scope** | Per-container defaults/enforcement | Namespace-wide totals |
| **When Applied** | At Pod creation | At Pod creation |
| **Prevents** | BestEffort Pods, resource abuse | Namespace resource exhaustion |
| **Use Together?** | âœ… **Yes!** (LimitRange ensures valid inputs â†’ Quota enforces totals) |  |

> ğŸ’¡ Your workflow:
> 
> 1. **LimitRange** â†’ ensures every Pod has valid resources
> 2. **ResourceQuota** â†’ ensures namespace doesnâ€™t exceed total budget

---

### â“ Common Questions

**Q: What if I set `defaultRequest` > `default`?**

A: âŒ **Invalid!** Kubernetes rejects the LimitRange with:

`requests.cpu cannot be greater than limits.cpu`

**Q: Does LimitRange apply to initContainers?**

A: âœ… **Yes!** But you can define **separate rules** for `type: Pod` or `type: PersistentVolumeClaim`.

**Q: Can I have multiple LimitRange objects in one namespace?**

A: âœ… **Yes!** Unlike ResourceQuota, multiple LimitRanges are **merged**.

**Q: Whatâ€™s the difference between `default` and `defaultLimit`?**

A: `default` = **`defaultLimit`** (older field name). Use `default`.

---

### â¡ï¸ Summary

âœ… **LimitRange** = auto-apply defaults + enforce min/max

âœ… **Prevents BestEffort Pods** and **resource abuse**

ğŸ” In k3s: Test with **no-resources Pod** â†’ see defaults applied

ğŸ› ï¸ **Always combine with ResourceQuota** for production clusters

â¡ï¸ Next: **CPU/Memory-specific LimitRanges** (`namespace-cpu-limitrange.yaml`)