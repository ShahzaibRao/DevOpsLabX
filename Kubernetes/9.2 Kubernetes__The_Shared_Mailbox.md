# 9.2: Shared `emptyDir` Between Containers

https://drive.google.com/file/d/1lDfGJRDPE999IBfSeOKfFqulswtLsXUA/view?usp=sharing

### ğŸ” YAML Breakdown

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: empty-multi
spec:
  containers:
  - name: boxone
    image: nginx
    volumeMounts:
    - mountPath: /demo          # â† Mounts volume at /demo
      name: demo-volume
  - name: boxtwo
    image: lovelearnlinux/webserver:v1
    volumeMounts:
    - mountPath: /var/www/html  # â† Mounts SAME volume at /var/www/html
      name: demo-volume
  volumes:
  - name: demo-volume
    emptyDir: {}                # â† Shared ephemeral storage

```

> ğŸ”‘ Key Insight:
> 
> 
> Both containers **share the same directory on the node**:
> 
> - `boxone` sees it as `/demo`
> - `boxtwo` sees it as `/var/www/html`
> â†’ **Any file written by one container is immediately visible to the other!**

> ğŸ’¡ Why this matters:
> 
> 
> This enables **decoupled, single-purpose containers** that collaborate via shared storage.
> 

---

### ğŸ“Œ Real-World Use Cases

| Pattern | How It Works |
| --- | --- |
| **Log Shipping** | App writes logs to `/var/log` â†’ Fluentd sidecar reads and ships them |
| **Config Reloading** | Config controller writes to `/config` â†’ App reloads config on change |
| **Metrics Exporter** | App writes metrics to `/metrics` â†’ Prometheus exporter scrapes them |
| **File Processing** | Downloader writes to `/data` â†’ Processor reads and transforms |

> ğŸ¯ Your Example:
> 
> - `boxtwo` (webserver) serves files from `/var/www/html`
> - `boxone` (nginx) could **write files** to `/demo` â†’ instantly served by `boxtwo`!

---

### ğŸ§ª k3s Lab: Share Data Between Containers

### ğŸ”§ Step 1: Deploy the Pod

```bash
# Apply Pod
kubectl apply -f empty-dir-multiple.yaml

# Verify both containers are running
kubectl get pods empty-multi

```

### ğŸ”§ Step 2: Write Data from `boxone` (nginx)

```bash
# Create a file in boxone's mount point
kubectl exec empty-multi -c boxone -- sh -c "echo '<h1>Hello from boxone!</h1>' > /demo/index.html"

# Verify file exists in boxone
kubectl exec empty-multi -c boxone -- cat /demo/index.html

```

### ğŸ”§ Step 3: Read Data from `boxtwo` (webserver)

```bash
# Check if file is visible in boxtwo
kubectl exec empty-multi -c boxtwo -- cat /var/www/html/index.html
# âœ… Same content: "Hello from boxone!"

# Test via web server
kubectl port-forward empty-multi 8080:80 &
curl <http://localhost:8080>
# âœ… "Hello from boxone!" â†’ served by boxtwo!

```

### ğŸ”§ Step 4: Simulate Failure (Data Survives Container Restart)

```bash
# Kill boxtwo container
kubectl exec empty-multi -c boxtwo -- kill 1

# Wait for restart
kubectl get pods empty-multi

# Verify data still there
curl <http://localhost:8080>
# âœ… Still works! â†’ `emptyDir` survives container restarts

```

### ğŸ”§ Step 5: Clean Up

```bash
kubectl delete pod empty-multi

```

---

### ğŸ’¡ Pro Tips for k3s

1. **Use descriptive mount paths**:
    - `/shared-logs`, `/app-config`, `/metrics-data`
    - Avoid generic paths like `/data`
2. **Set permissions if needed**:
    
    ```yaml
    securityContext:
      runAsUser: 1000
      fsGroup: 2000
    
    ```
    
3. **Monitor disk usage**:
    
    `emptyDir` consumes **node disk space** â†’ set `sizeLimit` if needed:
    
    ```yaml
    emptyDir:
      sizeLimit: "100Mi"
    
    ```
    

---

### ğŸ†š Single vs Multiple Container `emptyDir`

| Aspect | **Single Container** | **Multiple Containers** |
| --- | --- | --- |
| **Use Case** | Temporary scratch space | Inter-container communication |
| **Complexity** | Low | Medium |
| **Common Patterns** | Cache, temp files | Sidecar, adapter, ambassador |
| **Data Flow** | One-way (container â†’ disk) | Bi-directional (container â†” container) |

> ğŸ’¡ Sidecar Pattern:
> 
> 
> A **helper container** that extends the main appâ€™s functionality without modifying it.
> 

---

### â“ Common Questions

**Q: What if both containers write to the same file?**

A: âš ï¸ **Race conditions!** Use file locking or separate files.

**Q: Can I use different `mountPath` for each container?**

A: âœ… **Yes!** (As in your YAML) â€” each container chooses its own path.

**Q: Does `emptyDir` work with initContainers?**

A: âœ… **Yes!** InitContainers can **pre-populate** the volume before app containers start.

**Q: Whatâ€™s the performance impact?**

A: **None!** Itâ€™s just a directory on the nodeâ€™s filesystem.

---

### â¡ï¸ Summary

âœ… **Shared `emptyDir`** = enable **inter-container communication**

âœ… **Foundation of sidecar pattern** (log shipping, metrics, config)

âœ… **Data survives container restarts**, **not Pod deletion**

ğŸ” In k3s: Test by **writing in one container** â†’ **reading in another**

â¡ï¸ Next: **Pod volumes from external sources** (`pod-with-volume.yml`)