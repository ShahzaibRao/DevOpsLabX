# 05: Working with Files in Linux

## 1. Linux is Case-Sensitive

### Explanation

Linux treats uppercase and lowercase letters as **completely different characters**. This means `File.txt`, `file.txt`, and `FILE.TXT` are three distinct files.

### Example

```bash
touch Linux    # Creates a file named "Linux"
touch linux    # Creates a different file named "linux"
ls -li         # Lists files with inode numbers to show they're separate

```

### Lab Steps

1. Open a terminal.
2. Run:
    
    ```bash
    touch Linux linux LINUX
    ls -li
    
    ```
    
3. Observe that three separate files are created with different inode numbers.

### Tips & Warnings

- Always double-check capitalization when referencing files.
- Avoid using spaces and special characters in filenames to prevent shell escaping issues.

---

## 2. Everything in Linux is a File

### Explanation

In Linux, **everything is treated as a file**, including:

- Regular files (text, images, scripts)
- Directories (special files that list other files)
- Devices (e.g., hard drives, USB ports)
- System information (e.g., CPU details, memory stats)

This unified model simplifies system interactionâ€”you can "read" hardware or kernel data just like a text file.

### Examples

```bash
lsblk                 # Lists block devices (disks) as files
ls -l /dev/sda        # Shows /dev/sda as a block device file
cat /proc/cpuinfo     # Reads CPU info from a virtual file

```

### Lab Steps

1. Run `lsblk` to see your systemâ€™s disks.
2. Check device file details:
    
    ```bash
    ls -l /dev/sda
    
    ```
    
3. View system info:
    
    ```bash
    cat /proc/cpuinfo
    file /proc/cpuinfo
    
    ```
    

### Tips & Warnings

- **Never** run `cat /dev/sda` on a live systemâ€”it dumps raw disk data and may freeze your terminal.
- Files in `/proc` and `/sys` are **virtual**â€”they donâ€™t exist on disk but are generated by the kernel on-the-fly.

---

## 3. Creating and Identifying File Types

### Explanation

File **extensions** (like `.txt` or `.jpeg`) are **not used by Linux** to determine file type. Instead, the system checks the fileâ€™s **content/magic bytes** using the `file` command.

### Commands

```bash
cat > date.txt        # Create a text file
cat > date.jpeg       # Create a file named .jpeg (but it's still text!)
file date.txt         # Identifies actual content type
file date.jpeg        # Shows it's ASCII text, not a real JPEG

```

### Lab Steps

1. Create two files:
    
    ```bash
    echo "Hello" > test.txt
    echo "Fake image" > fake.jpeg
    
    ```
    
2. Check their true types:
    
    ```bash
    file test.txt
    file fake.jpeg
    
    ```
    
3. Observe that both are identified as "ASCII text"â€”**not** based on extension.

### Tips & Warnings

- Always use `file <filename>` to verify a fileâ€™s real type.
- Misleading extensions can cause security issues (e.g., a `.jpg` thatâ€™s actually a script).

---

## 4. Creating Hard and Soft (Symbolic) Links

### Explanation

Links are pointers to files. There are two types:

- **Hard link**: Direct reference to the fileâ€™s data (same inode). Deleting the original doesnâ€™t break it.
- **Soft link (symbolic link)**: A shortcut that points to the fileâ€™s path. Broken if the original is moved/deleted.

### Commands

```bash
# Create a hard link
ln original.txt hardlink.txt

# Create a soft link
ln -s original.txt softlink.txt

# View links
ls -l

```

### Lab Steps

1. Create a test file:
    
    ```bash
    echo "Link test" > original.txt
    
    ```
    
2. Create both link types:
    
    ```bash
    ln original.txt hardlink.txt
    ln -s original.txt softlink.txt
    
    ```
    
3. Check inodes and permissions:
    
    ```bash
    ls -li
    
    ```
    
    - Hard link shares the same inode as `original.txt`.
    - Soft link shows `lrwxrwxrwx` and points to the filename.
4. Test behavior:
    
    ```bash
    rm original.txt
    cat hardlink.txt    # Still works!
    cat softlink.txt    # "No such file" error
    
    ```
    

### Tips & Warnings

- Hard links **cannot** span across filesystems.
- Soft links can point to directories or files on other filesystems.
- Use `ls -l` to identify soft links (they show `> target`).

---

## 5. Managing File Timestamps with `touch`

### Explanation

Every file has three timestamps:

- **Access time (atime)**: Last read
- **Modify time (mtime)**: Last content change
- **Change time (ctime)**: Last metadata change (e.g., permissions)

The `touch` command updates these timestamps. By default, it sets them to the current time.

### Commands

```bash
touch filename                    # Create empty file or update timestamps
touch -t YYYYMMDDhhmm filename   # Set custom timestamp

```

### Example

```bash
touch -t 201005100615 oldfile.txt  # Sets timestamp to May 10, 2010, 06:15 AM
ls -l oldfile.txt

```

### Lab Steps

1. Create a file:
    
    ```bash
    touch current.txt
    
    ```
    
2. Set a custom timestamp:
    
    ```bash
    touch -t 200512251200 old.txt
    
    ```
    
3. Verify:
    
    ```bash
    ls -l current.txt old.txt
    
    ```
    

### Tips & Warnings

- Format for `t`: `[[CC]YY]MMDDhhmm[.ss]` (e.g., `201005100615` = May 10, 2010, 6:15 AM).
- `touch` creates an empty file if it doesnâ€™t exist.

---

## 6. Bulk File Creation and Deletion

### Explanation

You can create or delete many files at once using **brace expansion** (`{1..100}`) and **wildcards** (`*.txt`).

### Commands

```bash
# Create 100 files: 1.txt, 2.txt, ..., 100.txt
touch {1..100}.txt

# Delete all .txt files
rm *.txt

# Force-delete without prompts (dangerous!)
rm -rf *.txt

```

### Lab Steps

1. Create test files:
    
    ```bash
    touch {1..5}.txt
    ls
    
    ```
    
2. Delete them safely:
    
    ```bash
    rm *.txt
    
    ```
    
3. Recreate and force-delete (use cautiously):
    
    ```bash
    touch {1..3}.txt
    rm -rf *.txt
    
    ```
    

### Tips & Warnings

- **Always double-check wildcards** before using `rm -rf`â€”it **cannot be undone**.
- Test with `ls *.txt` first to confirm which files will be affected.
- `rm -r` is for directories; `rm -f` forces deletion without prompts.

---

## Summary Cheat Sheet

| Task | Command |
| --- | --- |
| Create empty file | `touch filename` |
| Set custom timestamp | `touch -t YYYYMMDDhhmm filename` |
| Identify file type | `file filename` |
| Create hard link | `ln source target` |
| Create soft link | `ln -s source target` |
| Create 100 files | `touch {1..100}.txt` |
| Delete all .txt files | `rm *.txt` |
| Force-delete (use carefully!) | `rm -rf *.txt` |

> ðŸ’¡ Golden Rule: In Linux, never trust the filename extensionâ€”always verify with file. And never run rm -rf without checking what it will delete!
>